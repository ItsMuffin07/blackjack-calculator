from functools import lru_cache
from time import time

EMPTY_DECK = (2, 2, 2, 2,
              3, 3, 3, 3,
              4, 4, 4, 4,
              5, 5, 5, 5,
              6, 6, 6, 6,
              7, 7, 7, 7,
              8, 8, 8, 8,
              9, 9, 9, 9,
              10, 10, 10, 10,
              10, 10, 10, 10,  # Jacks
              10, 10, 10, 10,  # Queens
              10, 10, 10, 10,  # Kings
              11, 11, 11, 11)  # Aces


def blackjack(cards: list) -> list:
    """
    :param cards: list of cards in deck
    :return: list containing total value, index 0 is the higher value if there is an ace
             returns [1,1] if game is over
             returns [value] when at 11, game is busted
             returns [higher value, lower value] for both combinations of ace
    """
    total = [0, 0]
    for card in cards:
        if card != 11:
            total[0] += card
            total[1] += card
        elif total[0] == total[1]:  # First ace
            total[0] += 11  # index 0 is the higher one
            total[1] += 1  # index 1 is the lower one
        else:  # When more than one ace
            total[0] += card
            total[1] += card
    if total[0] > 21 and total[1] > 21:  # Both busted
        return [1, 1]
    elif total[0] > 21 and total[1] <= 21:  # Busted only when Ace is at 11
        return [total[1]]
    else:
        return total


@lru_cache(maxsize=20_000)
def dealer_probability_busted(deck: tuple, dealer_hand: tuple, stand_value: int) -> float:  # Generated by AI by modifying my code
    '''
    :param deck: current branch deck
    :param dealer_hand: current branch hand
    :return: probability of current branch busting
    '''
    deck = list(deck)
    dealer_hand = list(dealer_hand)

    hand = blackjack(dealer_hand)

    # Check if the dealer has already busted
    if hand == [1, 1]:
        return 1.0

    # Determine the dealer's best hand value
    max_value = hand[0]
    if len(hand) > 1:
        min_value = hand[1]
    else:
        min_value = max_value

    # If the dealer should stand based on the higher value
    if max_value >= stand_value:
        return 0.0

    busted_probability = 0.0

    for card in deck:
        curr_probability = 1 / len(deck)  # Current branch probability

        temp_deck = deck.copy()
        temp_deck.remove(card)  # Remove card from the deck

        new_hand = dealer_hand.copy()
        new_hand.append(card)  # Add new card to hand

        branch_probability = dealer_probability_busted(deck=tuple(temp_deck),
                                                       dealer_hand=tuple(new_hand),
                                                       stand_value=stand_value)
        busted_probability += branch_probability * curr_probability

    return busted_probability


@lru_cache(maxsize=20_000)
def card_probabilities(deck: tuple, current_hand: tuple, value: int) -> float:  # Generated by AI by modifying my code
    '''
    :param deck: current branch deck
    :param current_hand: current branch hand
    :param value: the probability of getting a certain value
    :return: probability of current branch obtaining certain value or above (BUT VALID)
    '''
    deck = list(deck)
    current_hand = list(current_hand)

    hand = blackjack(current_hand)

    # Check if the hand has already busted
    if hand == [1, 1]:
        return 0.0

    # Determine the dealer's best hand value
    max_value = hand[0]
    if len(hand) > 1:
        min_value = hand[1]
    else:
        min_value = max_value

    # Determine if max value is the value that we are looking for or greater (not busted due to above)
    if max_value >= value or min_value >= value:
        return 1.0



    value_probability = 0.0

    for card in deck:
        curr_probability = 1 / len(deck)  # Current branch probability

        temp_deck = deck.copy()
        temp_deck.remove(card)  # Remove card from the deck

        new_hand = current_hand.copy()
        new_hand.append(card)  # Add new card to hand

        value_branch_probability = card_probabilities(deck=tuple(temp_deck),
                                                      current_hand=tuple(new_hand),
                                                      value=value)
        value_probability += value_branch_probability * curr_probability

    return value_probability


def player_probability_busted(deck: list, hand: list, dealer_card: int) -> float:
    '''
    :param deck: The deck before drawing
    :param hand: Player's cards
    :return: Probability of busting when pulling
    '''
    total: list = blackjack(hand)
    maximum_pull: int = 21 - total[-1]
    if total[0] == 1:  # Busted already
        return 0

    for card in hand:  # clear deck of our drawn cards
        deck.remove(card)

    deck.remove(dealer_card)  # clear deck of dealer known card

    can_pull: int = 0  # Counter for how many player can pull to not bust
    for card in deck:
        new_hand = hand.copy()
        new_hand.append(card)
        new_hand = blackjack(new_hand)[-1]
        added_value = new_hand - sum(hand)
        if added_value <= maximum_pull and new_hand != 1:
            can_pull += 1

    success_probability: float = can_pull / len(deck)  # probability that the next card pulled will not bust

    return success_probability

@lru_cache(maxsize=20_000)
def dealer_probability(deck: tuple, dealer_hand: tuple, value: int) -> float:
    '''
    :param deck: current branch deck
    :param dealer_hand: current branch hand
    :param value: target value
    :return: probability of current branch getting value
    '''
    deck = list(deck)
    dealer_hand = list(dealer_hand)

    hand = blackjack(dealer_hand)

    # Check if the dealer has already busted
    if hand == [1, 1]:
        return 0.0

    # Determine the dealer's best hand value
    max_value = hand[0]
    if len(hand) > 1:
        min_value = hand[1]
    else:
        min_value = max_value


    # If either value is at the target value
    if max_value == value or min_value == value:
        return 1.0
    elif max_value >= 17:  # No need to count as higher than value already
        return 0

    value_probability = 0.0

    for card in deck:
        curr_probability = 1 / len(deck)  # Current branch probability

        temp_deck = deck.copy()
        temp_deck.remove(card)  # Remove card from the deck

        new_hand = dealer_hand.copy()
        new_hand.append(card)  # Add new card to hand

        branch_probability = dealer_probability(deck=tuple(temp_deck),
                                                dealer_hand=tuple(new_hand),
                                                value=value)
        value_probability += branch_probability * curr_probability

    return value_probability





deck = list(EMPTY_DECK)

for i in range(7):
    temp = list(EMPTY_DECK)
    for card in temp:
        deck.append(card)


# Test dealer_probability_busted function
# start_time = time()
# print(dealer_probability_busted(tuple(deck),
#                                 dealer_hand=tuple([2]),
#                                 stand_value=17))
# print(dealer_probability_busted.cache_info())
# dealer_probability_busted.cache_clear()
# print(dealer_probability_busted.cache_info())
# end_time = time()
# print(f"Run time: {(end_time - start_time) * 1000}ms")

# Test dealer_probability function
start_time = time()

hand = [8]
total = 0
for i in range(17,22):
    temp = dealer_probability(deck=tuple(deck), dealer_hand=tuple(hand), value=i)
    print(i, temp)
    total += temp
bust = dealer_probability_busted(deck=tuple(deck),dealer_hand=tuple(hand),stand_value=17)
print(f"bust: {bust}")
total += bust
print(f"total: {total}")
print(dealer_probability.cache_info())

end_time = time()

print(f"Run time: {(end_time - start_time) * 1000}ms")